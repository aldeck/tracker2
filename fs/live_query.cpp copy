/*
 * Copyright 2005-2009, Haiku Inc. All Rights Reserved.
 * Distributed under the terms of the MIT license.
 *
 * Authors:
 *		Ficus Kirkpatrick (ficus@ior.com)
 *		Jérôme Duval
 *		Axel Dörfler, axeld@pinc-software.de
 */


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>

#include <Application.h>
#include <Directory.h>
#include <Entry.h>
#include <Node.h>
#include <NodeMonitor.h>
#include <Path.h>
#include <Query.h>
#include <fs_attr.h>
#include <Volume.h>
#include <VolumeRoster.h>
#include <String.h>

#include <ObjectList.h>

#include <map>

static const uint32 kMsgAddQuery = 'adqu';

extern const char *__progname;
static const char *kProgramName = __progname;

// Option variables.
static bool sAllVolumes = false;		// Query all volumes?
static bool sEscapeMetaChars = true;	// Escape metacharacters?
static bool sFilesOnly = false;			// Show only files?
static bool sVerbose = false;

static uint32 sEntryCount = 0;

struct lesserThanRefNode
{
  bool operator()(const node_ref & a, const node_ref & b)
  {
  	return a.device < b.device || (a.device == b.device && a.node < b.node);
  }
};


class LiveQuery : public BApplication {
public:
								LiveQuery();
	virtual						~LiveQuery();

	virtual	void				ArgvReceived(int32 argc, char** argv);
	virtual void				ReadyToRun();

	virtual void				MessageReceived(BMessage* message);

private:
			void				_PrintUsage();
			void				_AddQuery(BVolume& volume,
									const char* predicate);
			void				_PerformQuery(BQuery& query);

			void				_QueryUpdate(BMessage* message);
			void				_NodeMonitorUpdate(BMessage* message);

			void				_ManageEntry(const entry_ref& entry);
			void				_UnmanageEntry(const node_ref& node);
			void				_UpdateEntry(const node_ref& nodeRef, const entry_ref& entry);

			BObjectList<BQuery>	fQueries;
			bool				fArgsReceived;

			typedef std::map<node_ref, entry_ref, lesserThanRefNode> EntryMap;
			EntryMap			fEntries;
};


LiveQuery::LiveQuery()
	:
	BApplication("application/x-vnd.test-live-query"),
	fQueries(10, true),
	fArgsReceived(false)
{
}


LiveQuery::~LiveQuery()
{
}


void
LiveQuery::ArgvReceived(int32 argc, char** argv)
{
	fArgsReceived = true;

	// Which volume do we make the query on?
	// Default to the current volume.
	char volumePath[B_FILE_NAME_LENGTH];
	strcpy(volumePath, ".");

	// Parse command-line arguments.
	int opt;
	while ((opt = getopt(argc, argv, "efav:")) != -1) {
		switch (opt) {
			case 'e':
				sEscapeMetaChars = false;
				break;
			case 'f':
				sFilesOnly = true;
				break;
			case 'a':
				sAllVolumes = true;
				break;
			case 'v':
				strncpy(volumePath, optarg, B_FILE_NAME_LENGTH);
				break;

			default:
				_PrintUsage();
				break;
		}
	}

	BVolume volume;

	//printf("opt %s\n", argv[optind]);

	if (!sAllVolumes) {
		// Find the volume that the query should be performed on,
		// and set the query to it.
		BEntry entry(volumePath);
		if (entry.InitCheck() != B_OK) {
			fprintf(stderr, "%s: \"%s\" is not a valid file\n", kProgramName,
				volumePath);
			exit(1);
		}

		status_t status = entry.GetVolume(&volume);
		if (status != B_OK) {
			fprintf(stderr, "%s: could not get volume: %s\n", kProgramName,
				strerror(status));
			exit(1);
		}

		if (!volume.KnowsQuery()) {
			fprintf(stderr, "%s: volume containing %s is not query-enabled\n",
				kProgramName, volumePath);
		} else
			_AddQuery(volume, argv[optind]);
	} else {
		// Okay, we want to query all the disks -- so iterate over
		// them, one by one, running the query.
		BVolumeRoster volumeRoster;
		while (volumeRoster.GetNextVolume(&volume) == B_OK) {
			// We don't print errors here -- this will catch /pipe and
			// other filesystems we don't care about.
			if (volume.KnowsQuery())
				_AddQuery(volume, argv[optind]);
		}
	}
}


void
LiveQuery::ReadyToRun()
{
	if (!fArgsReceived)
		_PrintUsage();
}


void
LiveQuery::_ManageEntry(const entry_ref& entry)
{
	BNode node(&entry);
	status_t err2 = node.InitCheck();
	if (err2 != B_OK) {
		printf("error opening node err=%s\n", strerror(err2));
		return;
	} else {
		node_ref nodeRef;
   		node.GetNodeRef(&nodeRef);
		// debug check
		EntryMap::iterator it = fEntries.find(nodeRef);
		if (it != fEntries.end()) {
			printf("LiveQuery::_ManageEntry, already managed node=%lli!!\n", nodeRef.node);
			return;
		}

		fEntries.insert(EntryMap::value_type(nodeRef, entry));

		// needed for the "query entry rename" problem
		status_t err = watch_node(&nodeRef, B_WATCH_NAME | B_WATCH_STAT | B_WATCH_ATTR, this);
		sEntryCount++;
		if (sVerbose || err != B_OK) {
			BPath path(&entry);
			printf("%lu LiveQuery::_ManageEntry (%lli, %s). Start watching err=%s\n", sEntryCount,
				nodeRef.node, path.Path(), strerror(err));
		}

		// test, read some attributes

		/*	char buf[B_ATTR_NAME_LENGTH];
			//printf("attrs [ ");
			uint32 count = 0;
			while (node.GetNextAttrName(buf) == B_OK) {
	   			//printf("%s ", buf);
	   			attr_info info;
	   			status_t err3 = node.GetAttrInfo(buf, &info);
	   			if (err3 == B_OK) {
	   				// read all attributes
	   				char attrData[1024];
	   				if (info.size < 1024) {
		   				ssize_t read = node.ReadAttr(buf, (type_code)0, (off_t)0, attrData, info.size);
		   				//printf("read=%lu/%lu ", read, info.size);
		   				count++;
		   				if (count > 2)
		   					break;
		   			} else {
		   				//printf("toobig!=%lu ", info.size);
		   			}
	   			} else {
		   			//printf("noattrinfo '%s' ", strerror(err3));
		   		}
			}
			//printf("]\n");*/

	}
}


void
LiveQuery::_UnmanageEntry(const node_ref& nodeRef)
{
	EntryMap::iterator it = fEntries.find(nodeRef);
	if (it != fEntries.end()) {
		fEntries.erase(it);

		// needed for the "query entry rename" problem
		status_t err = B_OK; // watch_node(&nodeRef, B_STOP_WATCHING, this);

		if (sVerbose || err != B_OK) {
			BPath path(&it->second);
			printf("LiveQuery::_UnmanageEntry (%lli, %s), Stop watching B_WATCH_NAME err=%s\n",
				nodeRef.node, path.Path(), strerror(err));
		}
	} else
		printf("LiveQuery::_UnmanageEntry node %lli is not managed!!!\n", nodeRef.node);
}


void
LiveQuery::_UpdateEntry(const node_ref& nodeRef, const entry_ref& entry)
{
	EntryMap::iterator it = fEntries.find(nodeRef);
	if (it != fEntries.end()) {
		BPath fromPath(&it->second);
		it->second = entry;
		BPath toPath(&entry);
		printf("LiveQuery::_UpdateEntry (%lli, %s -> %s)\n", nodeRef.node, fromPath.Path(), toPath.Path());
	} else
		printf("LiveQuery::_UpdateEntry node %lli is not managed!!!\n", nodeRef.node);
}


void LiveQuery::_QueryUpdate(BMessage* message)
{
	int32 opcode;
	message->FindInt32("opcode", &opcode);

	int32 device;
	int64 directory;
	int64 node;
	const char* name;
	message->FindInt32("device", &device);
	message->FindInt64("directory", &directory);
	message->FindInt64("node", &node);
	message->FindString("name", &name);

	char info[B_PATH_NAME_LENGTH];
	sprintf(info, "device=%li directory=%lli node=%lli name=%s ", device, directory, node, name);

	switch (opcode) {
		case B_ENTRY_CREATED:
		{
			printf("%s QUERY_ B_ENTRY_CREATED\n", info);

			entry_ref entryRef;
			entryRef.device = device;
			entryRef.directory = directory;
			entryRef.set_name(name);

			_ManageEntry(entryRef);
			break;
		}
		case B_ENTRY_REMOVED:
		{
			printf("%s QUERY_ B_ENTRY_REMOVED\n", info);

			node_ref nodeRef;
			nodeRef.device = device;
			nodeRef.node = node;

			_UnmanageEntry(nodeRef);
			break;
		}
		default:
			printf("%s QUERY_ UNMANAGED OPCODE\n", info);
			BApplication::MessageReceived(message);
			break;
	}
}


void LiveQuery::_NodeMonitorUpdate(BMessage* message)
{
	int32 opcode;
	message->FindInt32("opcode", &opcode);

	int32 device;
	int64 directory;
	int64 node;
	const char* name;
	message->FindInt32("device", &device);
	message->FindInt64("directory", &directory);
	message->FindInt64("node", &node);
	message->FindString("name", &name);

	char info[B_PATH_NAME_LENGTH];
	sprintf(info, "device=%li directory=%lli node=%lli name=%s ", device, directory, node, name);

	switch (opcode) {
		case B_ENTRY_CREATED:
			printf("%s MONITOR_ B_ENTRY_CREATED\n", info);
			break;

		case B_ENTRY_REMOVED:
			printf("%s MONITOR_ B_ENTRY_REMOVED\n", info);
			break;

		case B_ENTRY_MOVED:
		{
			// can be about:
			// a query node that we're monitoring and which name has changed
			// a file in a directory that we monitor that moved in

			int64 fromDirectory;
			int64 toDirectory;
			message->FindInt64("from directory", &fromDirectory);
			message->FindInt64("to directory", &toDirectory);
			char info2[B_PATH_NAME_LENGTH];
			sprintf(info2, "device=%li fromdir=%lli todir=%lli node=%lli name=%s ", device, fromDirectory, toDirectory, node, name);
			printf("%s MONITOR_ B_ENTRY_MOVED\n", info2);

			node_ref nodeRef;
			nodeRef.device = device;
			nodeRef.node = node;

			entry_ref entryRef;
			entryRef.device = device;
			entryRef.directory = toDirectory;
			entryRef.set_name(name);

			_UpdateEntry(nodeRef, entryRef);
			break;
		}

		case B_STAT_CHANGED:
			printf("%s MONITOR_ B_STAT_CHANGED\n", info);
			break;

		case B_ATTR_CHANGED:
			printf("%s MONITOR_ B_ATTR_CHANGED\n", info);
			break;

		case B_DEVICE_MOUNTED:
			printf("%s MONITOR_ B_DEVICE_MOUNTED\n", info);
			break;

		case B_DEVICE_UNMOUNTED:
			printf("%s MONITOR_ B_DEVICE_UNMOUNTED\n", info);
			break;

		default:
			printf("%s MONITOR_ UNMANAGED OPCODE\n", info);
			BApplication::MessageReceived(message);
			break;
	}
}


void
LiveQuery::MessageReceived(BMessage* message)
{
	switch (message->what) {
		case kMsgAddQuery:
		{
			int32 device;
			const char* predicate;
			if (message->FindInt32("volume", &device) != B_OK
				|| message->FindString("predicate", &predicate) != B_OK)
				break;

			BVolume volume(device);
			BQuery* query = new BQuery;

			// Set up the volume and predicate for the query.
			query->SetVolume(&volume);
			query->SetPredicate(predicate);
			query->SetTarget(this);

			fQueries.AddItem(query);
			_PerformQuery(*query);
			break;
		}

		case B_QUERY_UPDATE:
			_QueryUpdate(message);
			break;

		case B_NODE_MONITOR:
			_NodeMonitorUpdate(message);
			break;

		default:
			BApplication::MessageReceived(message);
			break;
	}
}


void
LiveQuery::_PrintUsage()
{
	printf("usage: %s [ -ef ] [ -a || -v <path-to-volume> ] expression\n"
		"  -e\t\tdon't escape meta-characters\n"
		"  -f\t\tshow only files (ie. no directories or symbolic links)\n"
		"  -a\t\tperform the query on all volumes\n"
		"  -v <file>\tperform the query on just one volume; <file> can be any\n"
		"\t\tfile on that volume. Defaults to the current volume.\n"
		"  Hint: '%s name=bar' will find files named \"bar\"\n",
		kProgramName, kProgramName);

	Quit();
}


void
LiveQuery::_AddQuery(BVolume& volume, const char* predicate)
{
	printf("LiveQuery::_AddQuery predicate='%s'\n", predicate);
	BMessage add(kMsgAddQuery);
	add.AddInt32("volume", volume.Device());
	add.AddString("predicate", predicate);

	PostMessage(&add);
}


void
LiveQuery::_PerformQuery(BQuery& query)
{
	status_t status = query.Fetch();
	if (status != B_OK) {
		fprintf(stderr, "%s: bad query expression\n", kProgramName);
		return;
	}

	int32 count = 0;
	bigtime_t startTime = system_time();

	/*BEntry entry;
	BPath path;
	while (query.GetNextEntry(&entry) == B_OK) {
		if (sFilesOnly && !entry.IsFile())
			continue;

		if (entry.GetPath(&path) != B_OK) {
			fprintf(stderr, "%s: could not get path for entry\n", kProgramName);
			continue;
		}

		entry_ref ref;
		entry.GetRef(&ref); //TODO check error
		_ManageEntry(ref);

		count++;
	}*/

	BDirectory directory("/Data2/mail/Haiku-commits");// "/system/apps");//  /Data2/mail/Haiku-bugs
	status_t error = directory.InitCheck();

	if (error != B_OK)
		printf("directory.InitCheck error=%s\n", strerror(error));

	while (true) {
		entry_ref ref;
		status_t status = directory.GetNextRef(&ref);
		if (status != B_OK)
			break;

		_ManageEntry(ref);

		count++;
	}

	node_ref ref;
	directory.GetNodeRef(&ref);
	status = watch_node(&ref, B_WATCH_ALL, this);
	printf("Watching directory, status=%s\n", strerror(status));

	bigtime_t deltaTime = system_time() - startTime;
	printf("FOUND %ld entries, time %llims (%fms/kEntry)\n", count, deltaTime / 1000, (float)deltaTime / (float)count);
}


// #pragma mark -


int
main(int argc, char** argv)
{
	LiveQuery query;
	query.Run();

	return 0;
}
